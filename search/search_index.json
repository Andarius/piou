{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Piou is a CLI tool to build beautiful command-line interfaces with type validation.</p> <p> </p>"},{"location":"#quick-example","title":"Quick Example","text":"<p>It is as simple as:</p> <pre><code>from piou import Cli, Option\n\ncli = Cli(description='A CLI tool')\n\n@cli.command(cmd='foo', help='Run foo command')\ndef foo_main(\n        bar: int = Option(help='Bar positional argument (required)'),\n        baz: str = Option('-b', '--baz', help='Baz keyword argument (required)'),\n        foo: str | None = Option(None, '--foo', help='Foo keyword argument'),\n):\n    \"\"\"\n    A longer description on what the function is doing.\n    \"\"\"\n    pass\n\nif __name__ == '__main__':\n    cli.run()\n</code></pre> <p>The output will look like this:</p> <p><code>python -m examples.simple -h</code></p> <p></p> <p><code>python -m examples.simple foo -h</code></p> <p></p>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#derived-options","title":"Derived Options","text":"<p>Derived options allow you to group multiple arguments into a single object or reuse common argument patterns across commands (like database connection parameters).</p> <p>name: material   custom_dir: overrides</p>"},{"location":"advanced/#static-derived","title":"Static Derived","text":"<pre><code>from piou import Cli, Option, Derived, Password\nimport psycopg2\n\ndef get_pg_conn(\n        pg_user: str = Option('postgres', '--pg-user'),\n        pg_pwd: Password = Option('postgres', '--pg-pwd'),\n        pg_host: str = Option('localhost', '--pg-host'),\n        pg_port: int = Option(5432, '--pg-port'),\n        pg_db: str = Option('postgres', '--pg-db')\n):\n    conn = psycopg2.connect(dbname=pg_db, user=pg_user, password=pg_pwd,\n                            host=pg_host, port=pg_port)\n    return conn\n\n@cli.command(help='Run foo command')\ndef foo(pg_conn=Derived(get_pg_conn)):\n    # pg_conn is the connection object returned by get_pg_conn\n    ...\n</code></pre>"},{"location":"advanced/#dynamic-derived","title":"Dynamic Derived","text":"<p>You can also pass arguments to your derived generator functions:</p> <pre><code>def get_pg_url_dynamic(source: Literal['db1', 'db2']):\n    def _derived(\n            pg_host: str = Option(..., f'--host-{source}', arg_name=f'--host-{source}'),\n            ...\n    ):\n        return f'...'\n    return _derived\n\n@cli.command()\ndef dynamic(url_1: str = Derived(get_pg_url_dynamic('db1'))):\n    ...\n</code></pre> <p></p>"},{"location":"advanced/#on-command-run","title":"On Command Run","text":"<p>For debugging or auditing, you can hook into the command execution lifecycle using <code>on_cmd_run</code>.</p> <pre><code>from piou import Cli, CommandMeta\n\ndef on_cmd_run(meta: CommandMeta):\n    print(f\"Running command: {meta.cmd_name}\")\n    print(f\"Args: {meta.cmd_args}\")\n\ncli = Cli(description='A CLI tool', on_cmd_run=on_cmd_run)\n</code></pre>"},{"location":"advanced/#formatters","title":"Formatters","text":"<p>Piou provides two built-in formatters for help output and error messages.</p>"},{"location":"advanced/#richformatter-default","title":"RichFormatter (Default)","text":"<p>The default formatter uses Rich for colorful, styled terminal output.</p> <pre><code>from piou import Cli\nfrom piou.formatter import RichFormatter\n\ncli = Cli(formatter=RichFormatter(\n    cmd_color='cyan',\n    option_color='cyan',\n    default_color='white',\n    show_default=True,\n    use_markdown=True,\n    code_theme='solarized-dark',\n))\n</code></pre> <p>Options:</p> <ul> <li><code>cmd_color</code> - Color for command names</li> <li><code>option_color</code> - Color for option flags</li> <li><code>default_color</code> - Color for default values</li> <li><code>show_default</code> - Show default values in help output</li> <li><code>use_markdown</code> - Parse descriptions as Markdown</li> <li><code>code_theme</code> - Pygments theme for code blocks (see Pygments styles)</li> <li><code>use_rich_traceback</code> - Use Rich's traceback formatting for exceptions (default: <code>False</code>)</li> </ul> <p>For convenience, you can enable Rich tracebacks directly on the <code>Cli</code> class:</p> <pre><code>cli = Cli(use_rich_traceback=True)\n</code></pre>"},{"location":"advanced/#raw-formatter-plain-text","title":"Raw Formatter (Plain Text)","text":"<p>For plain text output without Rich dependencies, use the base <code>Formatter</code>:</p> <pre><code>from piou import Cli\nfrom piou.formatter import Formatter\n\ncli = Cli(formatter=Formatter())\n</code></pre>"},{"location":"advanced/#selecting-formatter","title":"Selecting Formatter","text":"<p>You can select the formatter in several ways:</p> <p>1. Environment variable:</p> <pre><code># Use raw (plain text) formatter\nPIOU_FORMATTER=raw python your_cli.py --help\n\n# Use Rich formatter (default)\nPIOU_FORMATTER=rich python your_cli.py --help\n</code></pre> <p>2. Using <code>get_formatter()</code>:</p> <pre><code>from piou import Cli\nfrom piou.formatter import get_formatter\n\n# Auto-detect (uses Rich if available, falls back to raw)\ncli = Cli(formatter=get_formatter())\n\n# Force specific formatter\ncli = Cli(formatter=get_formatter('raw'))\ncli = Cli(formatter=get_formatter('rich'))\n</code></pre> <p>3. Direct instantiation:</p> <pre><code>from piou import Cli\nfrom piou.formatter import Formatter, RichFormatter\n\ncli = Cli(formatter=Formatter())        # Raw\ncli = Cli(formatter=RichFormatter())    # Rich\n</code></pre>"},{"location":"advanced/#custom-formatter","title":"Custom Formatter","text":"<p>You can create your own formatter by subclassing <code>Formatter</code>:</p> <pre><code>from piou.formatter import Formatter\n\nclass MyFormatter(Formatter):\n    def print_cli_help(self, group):\n        # Custom help output\n        ...\n\n    def print_error(self, message):\n        # Custom error output\n        ...\n</code></pre>"},{"location":"advanced/#secret-and-password-types","title":"Secret and Password Types","text":"<p>Piou provides special types for handling sensitive values that should be masked in help output.</p>"},{"location":"advanced/#password-full-masking","title":"Password (Full Masking)","text":"<p>Use <code>Password</code> when values should be completely hidden:</p> <pre><code>from piou import Cli, Option, Password\n\n@cli.command()\ndef connect(\n    password: Password = Option(\"secret123\", \"--password\", help=\"Database password\"),\n):\n    pass\n</code></pre>"},{"location":"advanced/#secret-partial-masking","title":"Secret (Partial Masking)","text":"<p>Use <code>Secret</code> with <code>show_first</code> or <code>show_last</code> on the Option to reveal part of the value:</p> <pre><code>from piou import Cli, Option, Secret\n\n@cli.command()\ndef auth(\n    # Show first 3 chars: \"sk-******\"\n    api_key: Secret = Option(\"sk-12345678\", \"--api-key\", help=\"API key\", show_first=3),\n    # Show last 4 chars: \"******1234\"\n    card: Secret = Option(\"4111111111111234\", \"--card\", help=\"Card number\", show_last=4),\n):\n    pass\n</code></pre> <p>Both <code>Password</code> and <code>Secret</code> types are supported by all formatters to hide or partially mask default values in help output.</p>"},{"location":"features/","title":"Core Features","text":""},{"location":"features/#commands","title":"Commands","text":"<p>Commands are the core building blocks of your CLI. You define them using decorators.</p> <pre><code>from piou import Cli, Option\n\ncli = Cli(description='A CLI tool')\n\n@cli.command(cmd='foo', help='Run foo command')\ndef foo_main(\n        foo1: int = Option(help='Foo arguments'),\n        foo2: str = Option('-f', '--foo2', help='Foo2 arguments'),\n        foo3: str | None = Option(None, '-g', '--foo3', help='Foo3 arguments'),\n):\n    pass\n</code></pre> <p>In this case: - <code>foo1</code> is a required positional argument (no keyword flags, default is <code>...</code>). - <code>foo2</code> is a required keyword argument (has flags, default is <code>...</code>). - <code>foo3</code> is an optional keyword argument (has flags, default is <code>None</code>).</p> <p>Optional Ellipsis</p> <p><code>Option()</code> defaults to required (<code>...</code>), so <code>Option(help='...')</code> is equivalent to <code>Option(..., help='...')</code>.</p>"},{"location":"features/#global-options","title":"Global Options","text":"<p>You can specify global options that apply to all commands:</p> <pre><code>cli = Cli(description='A CLI tool')\ncli.add_option('-q', '--quiet', help='Do not output any message')\n</code></pre>"},{"location":"features/#docstrings-as-descriptions","title":"Docstrings as Descriptions","text":"<p>The description can also be extracted from the function docstring:</p> <pre><code>@cli.command(cmd='bar2')\ndef bar_2_main():\n    \"\"\"\n    Run foo command\n    \"\"\"\n    pass\n</code></pre>"},{"location":"features/#async-support","title":"Async Support","text":"<p>A command can also be asynchronous; it will be run automatically using <code>asyncio.run</code>.</p> <pre><code>@cli.command(cmd='bar', help='Run foo command')\nasync def bar_main():\n    pass\n</code></pre>"},{"location":"features/#default-command-main","title":"Default Command (Main)","text":"<p>Use the <code>@cli.main()</code> decorator (or <code>is_main=True</code>) to define a default command that runs when no named command is matched.</p> <pre><code>@cli.main()\ndef run_main():\n    pass\n</code></pre> <p>Run it directly: <pre><code>python -m examples.simple -h\n</code></pre></p> <p><code>@cli.main()</code> can also coexist with named commands. Named commands always take priority, and unmatched input falls back to the default command:</p> <pre><code>cli = Cli(description='My CLI')\n\n@cli.main()\ndef default(name: str = Option(...)):\n    print(f'Hello {name}')\n\n@cli.command('greet', help='Greet someone')\ndef greet(name: str = Option(..., '--name')):\n    print(f'Greetings, {name}!')\n</code></pre> <pre><code>python run.py world          # runs default: \"Hello world\"\npython run.py greet --name a # runs greet: \"Greetings, a!\"\n</code></pre>"},{"location":"features/#command-groups-sub-commands","title":"Command Groups / Sub-commands","text":"<p>You can nest commands arbitrarily deep using command groups.</p> <pre><code>sub_cmd = cli.add_command_group('sub', help='A sub command')\nsub_cmd.add_option('--test', help='Test mode')\n\n@sub_cmd.command(cmd='bar', help='Run bar command')\ndef sub_bar_main(**kwargs):\n    pass\n</code></pre> <p>Running <code>python run.py sub -h</code> will show the specific help for that group.</p> <p></p>"},{"location":"features/#options-processor","title":"Options Processor","text":"<p>Sometimes you need to intercept global options before a command runs (e.g., to set up logging level).</p> <pre><code>from piou import Cli, Option\n\ncli = Cli(description='A CLI tool')\n\n@cli.processor()\ndef processor(verbose: bool = Option(False, '--verbose', help='Increase verbosity')):\n    print(f'Processing {verbose=}')\n</code></pre> <p>By default, processed options are consumed. To pass them down to the command functions as well, use <code>propagate_options=True</code> when creating the <code>Cli</code> or sub-parser.</p> <p>You can also use <code>set_options_processor()</code> instead of the decorator. Options defined via <code>Option()</code> in the function signature are automatically extracted and registered as global options:</p> <pre><code>cli = Cli(description='A CLI tool')\n\ndef processor(\n    verbose: bool = Option(False, '-v', '--verbose'),\n    log_level: str | None = Option(None, '--log-level'),\n):\n    ...\n\ncli.set_options_processor(processor)\n</code></pre> <p>This is equivalent to using the <code>@cli.processor()</code> decorator.</p>"},{"location":"features/#error-handling","title":"Error Handling","text":""},{"location":"features/#commanderror","title":"CommandError","text":"<p>Use <code>CommandError</code> to display a user-friendly error message and exit with code 1, without showing a traceback.</p> <pre><code>from piou import Cli, Option\nfrom piou.exceptions import CommandError\n\ncli = Cli(description='A CLI tool')\n\n@cli.command(cmd='deploy', help='Deploy the application')\ndef deploy_main(\n    env: str = Option(help='Target environment'),\n):\n    if env not in ('staging', 'production'):\n        raise CommandError(f'Unknown environment: {env!r}')\n    ...\n</code></pre> <p>When raised inside a command, <code>CommandError</code> is caught by <code>Cli.run()</code> and the message is printed using the configured formatter \u2014 no Python traceback is shown to the user.</p> <p></p>"},{"location":"getting-started/","title":"Installation & Setup","text":""},{"location":"getting-started/#installation","title":"Installation","text":"pipuvconda <pre><code>pip install piou\n</code></pre> <pre><code>uv add piou\n</code></pre> <pre><code>conda install piou -c conda-forge\n</code></pre>"},{"location":"getting-started/#optional-raw-formatter","title":"Optional: Raw Formatter","text":"<p>By default, Piou uses Rich for colorful terminal output. If you prefer plain text output, you can use the raw formatter:</p> <pre><code># Via environment variable\nPIOU_FORMATTER=raw python your_cli.py --help\n\n# Or programmatically\nfrom piou import Cli\nfrom piou.formatter import get_formatter\n\ncli = Cli(formatter=get_formatter('raw'))\n</code></pre>"},{"location":"getting-started/#why-piou","title":"Why Piou?","text":"<p>I could not find a library that provided:</p> <ol> <li>The same developer experience as FastAPI.</li> <li>Customization of the interface (to build a CLI similar to Poetry).</li> <li>Type validation / casting.</li> </ol> <p>Typer is the closest alternative in terms of experience but lacks the possibility to format the output in a custom way using external libraries (like Rich).</p> <p>Piou provides all these possibilities and lets you define your own Formatter.</p>"},{"location":"migration/","title":"Migrating from Argparse","text":""},{"location":"migration/#moving-from-argparse","title":"Moving from <code>argparse</code>","text":"<p>If you are migrating from the standard library <code>argparse</code>, here are the key mappings.</p>"},{"location":"migration/#1-choices","title":"1. Choices","text":"<p>Argparse: <pre><code>parser.add_argument('--pick', choices=['foo', 'bar'])\n</code></pre></p> <p>Piou: <pre><code># Option A: Literal\npick: Literal['foo', 'bar'] = Option(None, '--pick')\n\n# Option B: Union of Literals\npick: Literal['foo'] | Literal['bar'] = Option(None, '--pick')\n\n# Option C: Explicit choices list\npick: str = Option(None, '--pick', choices=['foo', 'bar'])\n\n# Option D: Dynamic choices from a callable\ndef get_environments() -&gt; list[str]:\n    return ['prod', 'staging', 'dev']\n\nenv: str = Option(None, '--env', choices=get_environments)\n\n# Option E: Regex patterns in choices\nfrom piou import Regex\n\n# Accept \"prod\", \"staging\", or any string matching \"dev-\\d+\" (e.g., \"dev-123\")\nenv: str = Option(None, '--env', choices=['prod', 'staging', Regex(r'dev-\\d+')])\n\n# Mix literal values with multiple regex patterns\ndb_name: str = Option(..., '--db', choices=[\n    'production',\n    Regex(r'dev-\\d+'),           # matches dev-456\n])\n</code></pre></p> <p>Note: You can disable case sensitivity with <code>Option(..., case_sensitive=False)</code> for literal choices.</p> <p>Note: Regex patterns use <code>fullmatch</code>, meaning the entire value must match the pattern. The <code>case_sensitive</code> option only affects literal string choices, not regex patterns. For case-insensitive regex matching, use <code>Regex(r'...', re.IGNORECASE)</code>.</p>"},{"location":"migration/#2-boolean-flags-store-true","title":"2. Boolean Flags (Store True)","text":"<p>Argparse: <pre><code>parser.add_argument('--verbose', action='store_true')\n</code></pre></p> <p>Piou: <pre><code>verbose: bool = Option(False, '--verbose')\n</code></pre></p>"},{"location":"options/","title":"Option Reference","text":""},{"location":"options/#overview","title":"Overview","text":"<p><code>Option</code> defines command-line arguments with type validation, default values, and help text. It supports both positional and keyword arguments.</p> <pre><code>from piou import Option\n</code></pre>"},{"location":"options/#basic-syntax","title":"Basic Syntax","text":""},{"location":"options/#positional-arguments","title":"Positional Arguments","text":"<p>Arguments without flags are positional. They are required when using <code>...</code> (Ellipsis) as default:</p> <pre><code>@cli.command()\ndef greet(\n    name: str = Option(..., help=\"Name to greet\"),  # required positional\n    count: int = Option(1, help=\"Number of times\"),  # optional positional with default\n):\n    pass\n</code></pre> <p>Usage: <code>greet Alice 3</code></p>"},{"location":"options/#keyword-arguments","title":"Keyword Arguments","text":"<p>Add flag names to create keyword arguments:</p> <pre><code>@cli.command()\ndef fetch(\n    url: str = Option(..., \"-u\", \"--url\", help=\"URL to fetch\"),  # required keyword\n    timeout: int = Option(30, \"-t\", \"--timeout\", help=\"Timeout in seconds\"),  # optional\n):\n    pass\n</code></pre> <p>Usage: <code>fetch --url https://example.com -t 60</code></p>"},{"location":"options/#required-vs-optional","title":"Required vs Optional","text":"<ul> <li>Required: Use <code>...</code> (Ellipsis) as default</li> <li>Optional: Provide a default value (including <code>None</code>)</li> </ul> <pre><code>required_arg: str = Option(..., \"--name\")      # Must be provided\noptional_arg: str = Option(\"default\", \"--name\") # Has fallback\nnullable_arg: str | None = Option(None, \"--name\")  # Can be omitted\n</code></pre>"},{"location":"options/#parameters","title":"Parameters","text":"Parameter Type Description <code>default</code> <code>Any</code> Default value. Use <code>...</code> for required arguments. <code>*keyword_args</code> <code>str</code> Flag names (e.g., <code>\"-f\"</code>, <code>\"--foo\"</code>). Omit for positional args. <code>help</code> <code>str \\| None</code> Help text shown in <code>--help</code> output. <code>choices</code> <code>list \\| Callable</code> Restrict values to a list or callable returning a list. <code>case_sensitive</code> <code>bool</code> Whether choice matching is case-sensitive. Default: <code>True</code>. <code>raise_path_does_not_exist</code> <code>bool</code> For <code>Path</code> types, raise error if file doesn't exist. Default: <code>True</code>. <code>show_first</code> <code>int \\| None</code> For <code>Secret</code> types, show first N characters. <code>show_last</code> <code>int \\| None</code> For <code>Secret</code> types, show last N characters. <code>replacement</code> <code>str</code> Masking character for secrets. Default: <code>\"*\"</code>. <code>arg_name</code> <code>str \\| None</code> Override the argument name (used in dynamic Derived)."},{"location":"options/#supported-types","title":"Supported Types","text":"<p>Piou automatically validates and converts values based on type hints:</p> Type Format Example <code>str</code> Any string <code>\"hello\"</code> <code>int</code> Integer <code>42</code> <code>float</code> Decimal number <code>3.14</code> <code>bool</code> Flag (presence = True) <code>--verbose</code> <code>Path</code> File path (must exist) <code>./file.txt</code> <code>MaybePath</code> File path (may not exist) <code>./new-file.txt</code> <code>date</code> ISO format <code>2024-01-15</code> <code>datetime</code> ISO format <code>2024-01-15T10:30:00</code> <code>UUID</code> UUID format <code>550e8400-e29b-41d4-a716-446655440000</code> <code>dict</code> JSON object <code>'{\"key\": \"value\"}'</code> <code>list[T]</code> Space-separated values <code>item1 item2 item3</code> <code>Literal[\"a\", \"b\"]</code> One of the literal values <code>a</code> <code>Enum</code> Enum member name <code>DEBUG</code> <code>Password</code> String (fully masked in help) <code>secret123</code> <code>Secret</code> String (partially masked) <code>sk-****</code>"},{"location":"options/#path-types","title":"Path Types","text":"<pre><code>from pathlib import Path\nfrom piou import Option, MaybePath\n\n# File must exist (raises FileNotFoundError otherwise)\nconfig: Path = Option(..., \"--config\")\n\n# File may not exist yet\noutput: MaybePath = Option(..., \"--output\")\n\n# Or disable existence check explicitly\nlog: Path = Option(..., \"--log\", raise_path_does_not_exist=False)\n</code></pre>"},{"location":"options/#boolean-flags","title":"Boolean Flags","text":"<p>Boolean options act as flags\u2014their presence sets the value to <code>True</code>:</p> <pre><code>verbose: bool = Option(False, \"--verbose\", \"-v\")\n</code></pre> <p>Usage: <code>command --verbose</code> sets <code>verbose=True</code></p>"},{"location":"options/#list-types","title":"List Types","text":"<p>Lists are parsed as space-separated values:</p> <pre><code>files: list[str] = Option(..., \"--files\")\nnumbers: list[int] = Option([], \"--nums\")\n</code></pre> <p>Usage: <code>command --files a.txt b.txt c.txt</code></p>"},{"location":"options/#choices","title":"Choices","text":""},{"location":"options/#static-choices","title":"Static Choices","text":"<pre><code>env: str = Option(..., \"--env\", choices=[\"dev\", \"staging\", \"prod\"])\n</code></pre>"},{"location":"options/#literal-type-alternative","title":"Literal Type (Alternative)","text":"<pre><code>from typing import Literal\n\nenv: Literal[\"dev\", \"staging\", \"prod\"] = Option(..., \"--env\")\n</code></pre>"},{"location":"options/#dynamic-choices","title":"Dynamic Choices","text":"<p>Provide a callable that returns choices at runtime:</p> <pre><code>def get_environments() -&gt; list[str]:\n    return [\"dev\", \"staging\", \"prod\"]\n\nenv: str = Option(..., \"--env\", choices=get_environments)\n</code></pre> <p>Async callables are also supported:</p> <pre><code>async def fetch_envs() -&gt; list[str]:\n    return await api.get_environments()\n\nenv: str = Option(..., \"--env\", choices=fetch_envs)\n</code></pre>"},{"location":"options/#regex-patterns","title":"Regex Patterns","text":"<p>Use <code>Regex()</code> to allow values matching a pattern:</p> <pre><code>from piou import Regex\n\n# Accept \"prod\", \"staging\", or any \"dev-{number}\" pattern\nenv: str = Option(..., \"--env\", choices=[\n    \"prod\",\n    \"staging\",\n    Regex(r\"dev-\\d+\"),  # matches dev-1, dev-123, etc.\n])\n</code></pre> <p>For case-insensitive regex, use <code>re.IGNORECASE</code>:</p> <pre><code>import re\nfrom piou import Regex\n\nname: str = Option(..., \"--name\", choices=[Regex(r\"test.*\", re.IGNORECASE)])\n</code></pre>"},{"location":"options/#case-sensitivity","title":"Case Sensitivity","text":"<p>Disable case sensitivity for literal choices:</p> <pre><code># Accepts \"yes\", \"YES\", \"Yes\", etc.\nconfirm: Literal[\"yes\", \"no\"] = Option(..., \"--confirm\", case_sensitive=False)\n</code></pre> <p>Note: <code>case_sensitive</code> only affects literal string choices. For regex, use <code>re.IGNORECASE</code>.</p>"},{"location":"options/#secret-types","title":"Secret Types","text":""},{"location":"options/#password-full-masking","title":"Password (Full Masking)","text":"<p>Values are completely hidden in help output:</p> <pre><code>from piou import Password\n\ndb_pass: Password = Option(\"secret\", \"--password\")\n# Help shows: --password [default: ********]\n</code></pre>"},{"location":"options/#secret-partial-masking","title":"Secret (Partial Masking)","text":"<p>Reveal part of the value using <code>show_first</code> or <code>show_last</code>:</p> <pre><code>from piou import Secret\n\n# Show first 3 characters\napi_key: Secret = Option(\"sk-12345678\", \"--api-key\", show_first=3)\n# Help shows: --api-key [default: sk-*****]\n\n# Show last 4 characters\ncard: Secret = Option(\"4111111111111234\", \"--card\", show_last=4)\n# Help shows: --card [default: ************1234]\n</code></pre>"},{"location":"options/#custom-mask-character","title":"Custom Mask Character","text":"<pre><code>token: Secret = Option(\"abc123\", \"--token\", show_last=2, replacement=\"\u25cf\")\n# Help shows: --token [default: \u25cf\u25cf\u25cf\u25cf23]\n</code></pre>"},{"location":"options/#annotated-syntax","title":"Annotated Syntax","text":"<p>As an alternative to default value syntax, you can use <code>Annotated</code>:</p> <pre><code>from typing import Annotated\nfrom piou import Option\n\n@cli.command()\ndef greet(\n    name: Annotated[str, Option(..., help=\"Name to greet\")],\n    count: Annotated[int, Option(1, \"-c\", \"--count\", help=\"Repeat count\")],\n):\n    pass\n</code></pre> <p>Both syntaxes can be mixed and are equivalent:</p> <pre><code># These are equivalent:\nname: str = Option(..., \"--name\", help=\"User name\")\nname: Annotated[str, Option(..., \"--name\", help=\"User name\")]\n</code></pre>"},{"location":"options/#complete-example","title":"Complete Example","text":"<pre><code>from pathlib import Path\nfrom typing import Literal\nfrom piou import Cli, Option, Password, MaybePath, Regex\n\ncli = Cli(description=\"Database migration tool\")\n\n@cli.command(cmd=\"migrate\", help=\"Run database migrations\")\ndef migrate(\n    # Positional arguments\n    direction: Literal[\"up\", \"down\"] = Option(..., help=\"Migration direction\"),\n\n    # Required keyword arguments\n    database: str = Option(..., \"-d\", \"--database\", help=\"Database name\"),\n\n    # Optional with defaults\n    host: str = Option(\"localhost\", \"--host\", help=\"Database host\"),\n    port: int = Option(5432, \"--port\", help=\"Database port\"),\n\n    # Boolean flag\n    dry_run: bool = Option(False, \"--dry-run\", help=\"Preview without applying\"),\n\n    # Password (masked in help)\n    password: Password = Option(\"\", \"--password\", help=\"Database password\"),\n\n    # Path that may not exist\n    output: MaybePath = Option(None, \"--output\", help=\"Output log file\"),\n\n    # Dynamic choices with regex\n    env: str = Option(\"dev\", \"--env\", choices=[\"prod\", \"staging\", Regex(r\"dev-\\d+\")]),\n):\n    pass\n\nif __name__ == \"__main__\":\n    cli.run()\n</code></pre>"},{"location":"tui/","title":"TUI Mode","text":"<p>Beta Feature</p> <p>TUI mode is currently in beta. APIs may change in future releases.</p>"},{"location":"tui/#overview","title":"Overview","text":"<p>Piou includes an optional interactive TUI (Terminal User Interface) mode powered by Textual. Instead of running commands one at a time, you get a persistent interface with command suggestions, history, and rich output.</p> <p></p>"},{"location":"tui/#installation","title":"Installation","text":"<p>TUI mode requires the <code>textual</code> package. Install it with the <code>tui</code> extra:</p> <pre><code>pip install piou[tui]\n</code></pre>"},{"location":"tui/#enabling-tui-mode","title":"Enabling TUI Mode","text":"<p>There are three ways to enable TUI mode:</p> Constructor argumentEnvironment variableRuntime flag <pre><code>from piou import Cli\n\ncli = Cli(description=\"My CLI\", tui=True)\n</code></pre> <pre><code>PIOU_TUI=1 python my_cli.py\n</code></pre> <pre><code>python my_cli.py --tui\n</code></pre>"},{"location":"tui/#usage","title":"Usage","text":"<p>Once in TUI mode, you interact with your CLI through an input prompt:</p> <ul> <li>Commands start with <code>/</code> - Type <code>/hello</code> to run the <code>hello</code> command</li> <li>Arguments follow the command - <code>/hello World --loud</code></li> <li>Subcommands use <code>:</code> - <code>/stats:</code> shows subcommands, <code>/stats:up</code> filters them</li> </ul>"},{"location":"tui/#keyboard-shortcuts","title":"Keyboard Shortcuts","text":"Key Action <code>Tab</code> Accept suggestion and show argument placeholder <code>Up/Down</code> Cycle through suggestions or command history <code>Shift+Up</code> Scroll messages up (pauses autoscroll) <code>Shift+Down</code> Scroll messages down (re-enables autoscroll at bottom) <code>Enter</code> Execute the command <code>Ctrl+C</code> Clear input (press twice to exit) <code>Escape</code> Quit the TUI"},{"location":"tui/#command-suggestions","title":"Command Suggestions","text":"<p>As you type, suggestions appear below the input:</p> <ol> <li>Type <code>/</code> to see all available commands</li> <li>Continue typing to filter (e.g., <code>/he</code> shows <code>/hello</code>)</li> <li>Use <code>Up/Down</code> arrows to select</li> <li>Press <code>Tab</code> to accept and see argument hints</li> </ol>"},{"location":"tui/#command-history","title":"Command History","text":"<p>Your command history is persisted to <code>~/.{cli_name}_history</code>. Use <code>Up/Down</code> arrows when the suggestion list is empty to navigate through previous commands.</p>"},{"location":"tui/#example","title":"Example","text":"<pre><code>from piou import Cli, Option\n\ncli = Cli(description=\"Interactive CLI Demo\", tui=True)\n\n@cli.command(cmd=\"hello\", help=\"Say hello to someone\")\ndef hello(\n    name: str = Option(help=\"Name to greet\"),\n    loud: bool = Option(False, \"-l\", \"--loud\", help=\"Shout the greeting\"),\n):\n    message = f\"Hello, {name}!\"\n    if loud:\n        message = message.upper()\n    print(message)\n\n# Subcommands\nstats = cli.add_command_group(\"stats\", help=\"View statistics\")\n\n@stats.command(cmd=\"uploads\", help=\"Show upload statistics\")\ndef stats_uploads(\n    days: int = Option(7, \"-d\", \"--days\", help=\"Number of days\"),\n):\n    print(f\"Upload stats for {days} days...\")\n\nif __name__ == \"__main__\":\n    cli.run()\n</code></pre> <p>Run it:</p> <pre><code>python my_cli.py\n# or\npython my_cli.py --tui\n# or\nPIOU_TUI=1 python my_cli.py\n</code></pre> <p>Then in the TUI:</p> <pre><code>&gt; /hello World --loud\nHELLO, WORLD!\n\n&gt; /stats:uploads -d 30\nUpload stats for 30 days...\n</code></pre>"},{"location":"tui/#shell-commands","title":"Shell Commands","text":"<p>You can run shell commands directly by prefixing with <code>!</code>:</p> <pre><code>&gt; !ls -la\n&gt; !git status\n&gt; !echo \"Hello from shell\"\n</code></pre>"},{"location":"tui/#widget-layout","title":"Widget Layout","text":"<p>The TUI is composed of the following Textual widgets:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 #name                            \u2502\n\u2502 #description (optional)          \u2502 \u2190 scrollable\n\u2502 #messages (Vertical)             \u2502\n\u2502   ...                            \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 #status-above (hidden by default)\u2502\n\u2502 #rule-above                      \u2502\n\u2502 #input-row (Horizontal)          \u2502\n\u2502   #prompt  Input                 \u2502\n\u2502 #rule-below                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 #context-panel (Vertical)        \u2502\n\u2502   #hint                          \u2502\n\u2502   #suggestions (Vertical)        \u2502\n\u2502   #value-picker (ValuePicker)    \u2502\n\u2502   #command-help                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tui/#tuicontext","title":"TuiContext","text":"<p>Commands can interact with the TUI through <code>TuiContext</code>. Inject it using <code>TuiOption()</code>:</p> <pre><code>from piou import Cli, Option\nfrom piou.tui import TuiContext, TuiOption\n\ncli = Cli(description=\"My CLI\", tui=True)\n\n@cli.command(cmd=\"greet\")\ndef greet(name: str = Option(), ctx: TuiContext = TuiOption()):\n    ctx.notify(f\"Hello, {name}!\", title=\"Greeting\")\n</code></pre>"},{"location":"tui/#available-methods","title":"Available Methods","text":"Method Description <code>ctx.is_tui</code> <code>True</code> if running in TUI mode <code>ctx.notify(message, title, severity)</code> Show a toast notification <code>ctx.mount_widget(widget)</code> Mount a Textual widget to the output <code>ctx.prompt(message)</code> Await user input (async) <code>ctx.set_hint(text)</code> Set hint text below input <code>ctx.set_rule_above(...)</code> Style the rule above input <code>ctx.set_rule_below(...)</code> Style the rule below input <code>ctx.set_prompt_style(style)</code> Change the input prompt style <p>All methods are no-ops in CLI mode, so your commands work in both modes.</p>"},{"location":"tui/#notifications","title":"Notifications","text":"<pre><code>@cli.command(cmd=\"process\")\ndef process(ctx: TuiContext = TuiOption()):\n    ctx.notify(\"Starting...\", title=\"Process\", severity=\"information\")\n    # ... do work ...\n    ctx.notify(\"Done!\", severity=\"information\")\n    # severity can be: \"information\", \"warning\", \"error\"\n</code></pre>"},{"location":"tui/#mounting-widgets","title":"Mounting Widgets","text":"<p>Mount any Textual widget to display rich output:</p> <pre><code>from textual.widgets import DataTable, ProgressBar\n\n@cli.command(cmd=\"stats\")\nasync def stats(ctx: TuiContext = TuiOption()):\n    table = DataTable()\n    table.add_columns(\"Name\", \"Value\")\n    table.add_row(\"Users\", \"1,234\")\n    table.add_row(\"Events\", \"56,789\")\n    ctx.mount_widget(table)\n</code></pre>"},{"location":"tui/#streaming-output","title":"Streaming Output","text":"<p>Use <code>StreamingMessage</code> to display content that arrives incrementally (e.g. LLM tokens, progress lines). It accumulates text via <code>append()</code> and respects autoscroll \u2014 users can scroll up to pause and scroll back down to resume.</p> <pre><code>import asyncio\nfrom piou.tui import StreamingMessage, TuiContext, TuiOption\n\n@cli.command(cmd=\"generate\")\nasync def generate(ctx: TuiContext = TuiOption()):\n    widget = StreamingMessage()\n    ctx.mount_widget(widget)\n    for i in range(20):\n        widget.append(f\"Line {i + 1}\\n\")\n        await asyncio.sleep(0.1)\n    widget.append(\"Done.\")\n</code></pre>"},{"location":"tui/#prompting-for-input","title":"Prompting for Input","text":"<pre><code>@cli.command(cmd=\"confirm\")\nasync def confirm(ctx: TuiContext = TuiOption()):\n    response = await ctx.prompt(\"Are you sure? (y/n) \")\n    if response and response.lower() == \"y\":\n        print(\"Confirmed!\")\n    else:\n        print(\"Cancelled\")\n</code></pre>"},{"location":"tui/#lifecycle-hooks","title":"Lifecycle Hooks","text":""},{"location":"tui/#tui_on_ready","title":"tui_on_ready","text":"<p>Run code when the TUI is fully initialized:</p> <pre><code>@cli.tui_on_ready\ndef on_ready():\n    print(\"TUI is ready!\")\n</code></pre>"},{"location":"tui/#custom-styling","title":"Custom Styling","text":""},{"location":"tui/#css-parameter","title":"CSS Parameter","text":"<p>Pass custom CSS to style the TUI:</p> <pre><code>cli = Cli(\n    description=\"Styled CLI\",\n    tui=True,\n)\n\n# In your app setup or via TuiApp directly:\napp = cli.tui_app(css=\"\"\"\n    #name {\n        color: cyan;\n        text-style: bold;\n    }\n    .suggestion.selected {\n        background: darkblue;\n    }\n\"\"\")\n</code></pre>"},{"location":"tui/#css-classes","title":"CSS Classes","text":"Class Element <code>.suggestion</code> Command suggestion items <code>.selected</code> Currently selected suggestion <code>.message</code> User input messages <code>.output</code> Command output <code>.error</code> Error output"},{"location":"tui/#widget-ids","title":"Widget IDs","text":"ID Element <code>#name</code> CLI name header <code>#description</code> CLI description <code>#messages</code> Messages container <code>#input-row</code> Input row container <code>#prompt</code> Input prompt (<code>&gt;</code>) <code>#suggestions</code> Suggestions container <code>#value-picker</code> Option value picker grid <code>#command-help</code> Command help display <code>#hint</code> Hint text <code>#rule-above</code> Rule above input <code>#rule-below</code> Rule below input"},{"location":"tui/#promptstyle","title":"PromptStyle","text":"<p>Customize the input prompt:</p> <pre><code>from piou.tui import PromptStyle\n\n@cli.command(cmd=\"login\")\nasync def login(ctx: TuiContext = TuiOption()):\n    # Change prompt for password input\n    prev_style = ctx.set_prompt_style(PromptStyle(text=\"Password: \", css_class=\"password-prompt\"))\n    password = await ctx.prompt()\n    # Restore previous style\n    if prev_style:\n        ctx.set_prompt_style(prev_style)\n</code></pre>"},{"location":"tui/#limitations","title":"Limitations","text":"<ul> <li>TUI mode captures stdout/stderr, so interactive prompts inside commands won't work as expected (use <code>ctx.prompt()</code> instead)</li> <li>The <code>/help</code> command shows the CLI help; individual command help is shown when you press <code>Tab</code> or run <code>/command --help</code></li> </ul>"}]}